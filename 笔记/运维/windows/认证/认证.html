<!DOCTYPE html>
<!-- saved from url=(0076)file:///C:/Users/ppom/AppData/Local/Temp/mume2020427-12400-77z395.6u9qe.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>认证</title>
      
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="./认证_files/katex.min.css">
      
      
      
      
      
      
      
      
      
      <style>
      /**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}

/* highlight */
pre[data-line] {
  position: relative;
  padding: 1em 0 1em 3em;
}
pre[data-line] .line-highlight-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  background-color: transparent;
  display: block;
  width: 100%;
}

pre[data-line] .line-highlight {
  position: absolute;
  left: 0;
  right: 0;
  padding: inherit 0;
  margin-top: 1em;
  background: hsla(24, 20%, 50%,.08);
  background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));
  pointer-events: none;
  line-height: inherit;
  white-space: pre;
}

pre[data-line] .line-highlight:before, 
pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-start);
  position: absolute;
  top: .4em;
  left: .6em;
  min-width: 1em;
  padding: 0 .5em;
  background-color: hsla(24, 20%, 50%,.4);
  color: hsl(24, 20%, 95%);
  font: bold 65%/1.5 sans-serif;
  text-align: center;
  vertical-align: .3em;
  border-radius: 999px;
  text-shadow: none;
  box-shadow: 0 1px white;
}

pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-end);
  top: auto;
  bottom: .4em;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
    </head>
    <body for="html-export">
      <div class="mume markdown-preview  ">
      <h1 class="mume-header" id="%E8%AE%A4%E8%AF%81">认证</h1>

<blockquote>
<p>注 : 笔记中拓扑图 drawio 源文件在其图片目录下</p>
</blockquote>
<hr>
<p><strong>认证的应用</strong></p>
<p>在域环境下，可以使用 Kerberos 或者 NTLM认证来实现对用户的身份认证。在很多企业的内部网络中(基本都是域环境)，都是使用 Kerberos认证或 NTLM 认证，在 Windows 2000 以后，在域环境下，Kerberos 是默认的认证方式。因为由于 NTLM 认证存在安全风险，所以用 Kerberos 认证的较多。Kerberos 较之 NTLM 更高效、更安全，同时认证过程也相对复杂。在非域环境下，一般都是使用 NTLM 进行认证。SMB 服务和很多 Web 程序都是使用 NTLM 来实现对用户的身份认证。</p>
<hr>
<h1 class="mume-header" id="%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81">本地认证</h1>

<p>在 Windows 系统中本机的用户密码以 hash 形式存储在 <code>%SystemRoot%\system32\config\sam</code> 数据库文件中。sam 的简称是Security Account Manager，安全账户管理器。被保存的 hash 分为 <code>LM Hash</code> 和 <code>NTLM hash</code>；微软在 Windows NT 4.0 中引入 SYSKEY 对 <code>SAM</code> 文件加密。而域内用户的密码 Hash 是存在域控的 <code>NTDS.DIT</code> 文件里面。</p>
<p>这个 SAM 文件中保留了计算机本地所有用户的凭证信息，可以理解为是一个数据库。登录系统的时候,系统会自动地读取 <code>SAM</code> 文件中的密码与键入的密码进行比对，如果相同，则认证成功。</p>
<p>操作系统启动之后，<code>SAM</code> 文件将同时被锁定。这意味着操作系统运行之时，用户无法打开或复制 <code>SAM</code> 文件。除了锁定，整个 <code>SAM</code> 文件还经过加密，且不可见。</p>
<p><strong>哈希（hash）</strong></p>
<p>Windows 本身不保存明文密码，只保留密码的 Hash。为了保证存储的不是明文，从而采用 Hash，但是密码 Hash 也需要特定的生成算法以及表现形式。</p>
<p>Hash 就是使用一种加密函数进行计算后的结果。这个加密函数对一个任意长度的字符串数据进行一次数学加密函数运算，然后返回一个固定长度的字符串。现在已经有了更新的 NTLMv2 以及 Kerberos 验证体系。Windows 加密过的密码口令，我们称之为 hash，Windows 的系统密码 hash 默认情况下一般由两部分组成：第一部分是 LM-hash，第二部分是 NTLM-hash。</p>
<hr>
<h2 class="mume-header" id="lm-hash">LM-Hash</h2>

<p>LAN Manager（LM）哈希是 Windows 系统所用的第一种密码哈希算法，是一种较古老的 Hash，在 LAN Manager 协议中使用，非常容易通过暴力破解获取明文凭据。它只有唯一一个版本且一直用到了 NT LAN Manager（NTLM）哈希的出现，在 Windows Vista/Windows 7/Windows Server 2008 以及后面的系统中，LM 哈希算法是默认关闭的，LM 算法是在 DES 基础上实现的，不区分字母大小写，由 IBM 设计。</p>
<p><strong>生成原理</strong></p>
<ol>
<li>用户的密码转换为大写，密码转换为16进制字符串，不足14字节将会用0来再后面补全。</li>
<li>密码的16进制字符串被分成两个 7byte 部分。每部分转换成比特流，并且长度位 56bit，长度不足用0在左边补齐长度</li>
<li>再分 7bit 为一组,每组末尾加 0，再组成一组</li>
<li>上步骤得到的二组，分别作为 key 为 <code>KGS!@#$%</code> 进行 DES 加密。</li>
<li>将加密后的两组拼接在一起，得到最终 LM HASH 值。</li>
</ol>
<p><strong>风险</strong></p>
<p>LM 加密算法存在一些固有的漏洞</p>
<ol>
<li>首先，密码长度最大只能为14个字符</li>
<li>密码不区分大小写。在生成哈希值之前，所有密码都将转换为大写</li>
<li>查看我们的加密过程，就可以看到使用的是分组的 DES，如果密码强度是小于 7 位，那么第二个分组加密后的结果肯定是 aad3b435b51404ee，同理,如果我们看到 lm hash 的结尾是 aad3b435b51404ee，就可以判断密码强度少于7位</li>
<li>一个14个字符的密码分成7 + 7个字符，并且分别为这两个半部分计算哈希值。这种计算哈希值的方式使破解难度成倍增加，因为攻击者需要将7个字符（而不是14个字符）强制暴力破解。这使得14个字符的密码的有效强度等于，或者是7个字符的密码的两倍，该密码的复杂度明显低于 95<sup>14</sup> 14个字符的密码的理论强度。</li>
<li>Des 密码强度不高</li>
</ol>
<hr>
<h2 class="mume-header" id="ntlm-hash">NTLM-Hash</h2>

<p><strong>NTLM Hash</strong></p>
<p>为了解决 LM 加密和身份验证方案中固有的安全弱点，Microsoft 于 1993 年在 Windows NT 3.1 中引入了 NTLM 协议。</p>
<p>NT LAN Manager（NTLM）哈希是 Windows 系统认可的另一种算法，用于替代古老的 LM-Hash，一般指 Windows 系统下 Security Account Manager（SAM）中保存的用户密码 hash，在 Windows Vista/Windows 7/Windows Server 2008 以及后面的系统中，NTLM 哈希算法是默认启用的。</p>
<p>下面是各个版本对 LM 和 NTLM 的支持。</p>
<table>
<thead>
<tr>
<th></th>
<th>2000</th>
<th>XP</th>
<th>2003</th>
<th>Vista</th>
<th>Win7</th>
<th>2008</th>
<th>Win8</th>
<th>2012</th>
</tr>
</thead>
<tbody>
<tr>
<td>LM</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>NTLM</td>
<td>🔺</td>
<td>🔺</td>
<td>🔺</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody>
</table>
<hr>
<table>
<thead>
<tr>
<th>✔</th>
<th>系统默认使用的加密方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>🔺</td>
<td>当密码超过14位时使用的加密方式</td>
</tr>
</tbody>
</table>
<p>当用户登录时，将用户输入的明文密码加密成 <code>NTLM Hash</code>，与 <code>SAM</code> 数据库文件中的 <code>NTLM Hash</code> 进行比较。</p>
<p>在渗透测试中，通常可从 Windows 系统中的 <code>SAM</code> 文件和域控的 <code>NTDS.dit</code> 文件中获得所有用户的 hash，通过 Mimikatz 读取 <code>lsass.exe</code> 进程能获得已登录用户的 <code>NTLM hash</code>。</p>
<p><strong>生成原理</strong></p>
<ol>
<li>先将用户密码转换为十六进制格式。</li>
<li>将十六进制格式的密码进行 Unicode 编码。</li>
<li>使用 MD4 摘要算法对 Unicode 编码数据进行 Hash 计算</li>
</ol>
<p><strong>快速生成</strong></p>
<pre data-role="codeBlock" data-info="bash" class="language-bash">python2 -c <span class="token string">'import hashlib,binascii; print binascii.hexlify(hashlib.new("md4", "P@ssw0rd".encode("utf-16le")).digest())'</span>
</pre><p><strong>NTLM Hash 与 NTLM 的关系</strong></p>
<p>在 Windows 中，密码 Hash 目前称之为 NTLM Hash，其中 NTLM 全称是：“NT LAN Manager”。</p>
<p>而 NTLM 是一种网络认证协议，与 NTLM Hash 的关系就是：NTLM 网络认证协议是以 NTLM Hash 作为根本凭证进行认证的协议。也就是说，NTLM 与 NTLM Hash 相互对应。</p>
<p>在本地认证的过程中，其实就是将用户输入的密码转换为 NTLM Hash 与 SAM 中的 NTLM Hash 进行比较。</p>
<hr>
<h2 class="mume-header" id="%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B">本地认证流程</h2>

<p>本地登录时，用户的密码存储在 <code>%SystemRoot%\system32\config\SAM</code> 这个文件里。当用户输入密码进行本地认证的过程中，所有的操作都是在本地进行的。他其实就是将用户输入的密码转换为 NTLM Hash，然后与 SAM 中的 NTLM Hash 进行比较。当用户注销、重启、锁屏后，操作系统会让 winlogon 显示登录界面，也就是输入框。当 winlogon.exe 接收输入后，将密码交给 lsass 进程，这个进程中会存一份明文密码，将明文密码加密成 NTLM Hash，对 SAM 数据库比较认证。</p>
<ul>
<li>Windows Logon Process(即 winlogon.exe)，是Windows NT 用户登陆程序，用于管理用户登录和退出。</li>
<li>LSASS 用于微软 Windows 系统的安全机制。用于本地安全和登陆策略。</li>
</ul>
<p><strong>参考如下</strong></p>
<pre data-role="codeBlock" data-info="bash" class="language-bash">winlogon.exe -<span class="token operator">&gt;</span> 接收用户输入 -<span class="token operator">&gt;</span> lsass.exe -<span class="token operator">&gt;</span> 认证
</pre><ol>
<li>
<p>当刚开机、注销等操作后，winlogon.exe 进程会显示一个登录界面要求输入用户名和密码。</p>
</li>
<li>
<p>输入用户名和密码后，会被 winlogon.exe 获取，然后将其发送给 lsass.exe 进程。</p>
</li>
<li>
<p>lsass.exe 将明文密码计算得到 NT Hash（不考虑LM）。</p>
</li>
<li>
<p>之后会将用户名和密码计算得到的 NT Hash 拿到 SAM 数据库去查找比对。</p>
<p><img src="./认证_files/1.png" alt=""></p>
</li>
</ol>
<hr>
<h1 class="mume-header" id="%E7%BD%91%E7%BB%9C%E8%AE%A4%E8%AF%81">网络认证</h1>

<p>在内网渗透中，经常遇到工作组环境，而工作组环境是一个逻辑上的网络环境(工作区)，隶属于工作组的机器之间无法互相建立一个完美的信任机制，只能点对点，是比较落后的认证方式，没有信托机构。</p>
<p>假设 A 主机与 B 主机属于同一个工作组环境，A 想访问 B 主机上的资料，需要将一个存在于 B 主机上的账户凭证发送至 B 主机，经过认证才能够访问 B 主机上的资源。</p>
<p>这是我们接触比较多的 SMB 共享文件的案例，SMB 的默认端口是 445。</p>
<p>早期 SMB 协议在网络上传输明文口令。后来出现 LAN Manager Challenge/Response 验证机制，简称 LM，它很容易被破解，就又有了 NTLM 以及 Kerberos。</p>
<hr>
<h2 class="mume-header" id="lm">LM</h2>

<p>LM 与 NTLM 协议的认证机制相同，但是加密算法不同。</p>
<p>目前大多数的 Windows 都采用 NTLM 协议认证，LM 协议已经基本淘汰了。</p>
<hr>
<h2 class="mume-header" id="ntlm">NTLM</h2>

<p>NTLM 是一种网络认证协议,以 NTLM Hash 作为凭证进行认证。NTLM Hash 长度为32位，由数字和字母组成,采用挑战/响应（Challenge/Response）的消息交换模式，</p>
<p>这个协议只支持 Windows.</p>
<p>NTLM 协议的认证过程分为三步：</p>
<ul>
<li>协商 : 主要用于确认双方协议版本</li>
<li>质询 : 就是挑战（Challenge）/响应（Response）认证机制起作用的范畴</li>
<li>验证 : 验证主要是在质询完成后，验证结果，是认证的最后一步。</li>
</ul>
<h3 class="mume-header" id="challengeresponse">Challenge/Response</h3>

<ol>
<li>
<p>客户端需要访问服务器的某个服务(前提是他得知道服务器的用户名和密码)，所以得进行身份认证。于是，客户端输入服务器的用户名和密码进行验证，客户端会缓存服务器密码的 NTLM-Hash 值。客户端发送 TYPE 1 Negotiate 协商消息去协商需要认证的主体，用户(服务器端的用户名)，机器以及需要使用的安全服务等等信息。</p>
</li>
<li>
<p>服务端接收到客户端发送过来的 TYPE 1 消息，会读取其中的内容，并从中选择出自己所能接受的服务内容，加密等级，安全服务等等。然后传入 NTLM SSP，得到 NTLM_CHALLENGE 消息（被称为 TYPE 2 消息，Challenge 挑战消息），并将此 TYPE 2 消息发回给客户端。此TYPE 2消息中包含了一个由服务端生成的 16 位随机值，此随机值被称为 Challenge，服务器将该 Challenge 保存起来。</p>
</li>
<li>
<p>客户端收到服务端返回的 TYPE 2 消息， 读取出服务端所支持的内容，并取出其中的随机值 Challenge，用缓存的服务器端密码的哈希值 NTLM-Hash 对其进行加密，得到 Net NTLM-Hash(加密后的 Challenge)，并且将 Net NTLM-Hash 封装到 NTLM_AUTH 消息中（被称为 TYPE 3 消息， Authenticate 认证消息），发往服务端。</p>
</li>
<li>
<p>服务器在收到 Type3 的消息之后，用自己的密码的 NTLM-Hash 对 Challenge 进行加密，并比较自己计算出的 Net NTLM-Hash 认证消息和客户端发送的认证消息是否匹配。如果匹配，则证明客户端掌握了正确的密码，认证成功，否则认证失败。</p>
<p><img src="./认证_files/20.png" alt=""></p>
</li>
</ol>
<p><strong>详细过程</strong></p>
<ul>
<li>
<p>type 1 协商</p>
<p>这个过程是客户端向服务器发送 type 1(协商)消息,它主要包含客户端支持和服务器请求的功能列表。</p>
<p>主要包含以下结构</p>
<p><img src="./认证_files/26.png" alt=""></p>
<p><img src="./认证_files/27.png" alt=""></p>
</li>
<li>
<p>type 2 质询</p>
<p>这个过程是服务器用 type 2 消息(质询)进行响应，这包含服务器支持和同意的功能列表。但是，最重要的是，它包含服务器产生的 Challenge。</p>
<p>主要包含以下结构</p>
<p><img src="./认证_files/28.png" alt=""></p>
<p>其中最主要的信息是 challenge。后面加密验证依赖于 challenge</p>
<p><img src="./认证_files/29.png" alt=""></p>
</li>
<li>
<p>type 3 身份验证</p>
<p>这个过程客户端接收到 challenge 之后，使用用户 hash 与 challenge 进行加密运算得到 response，将 response,username,challenge 发给服务器。消息中的 response 是最关键的部分，因为它向服务器证明客户端用户已经知道帐户密码。</p>
<p>主要包含以下结构</p>
<p><img src="./认证_files/30.png" alt=""></p>
<p>这里的 Challeng 不同于 type2 的 Challenge，这里的 Challenge 是一个随机的客户端 nonce。</p>
<p>MIC 是校验和，设计 MIC 主要是为了防止这个包中途被修改</p>
<p>sessionkey 是在要求进行签名的时候用的，用来进行协商加密密钥，可能有些文章会说 sessionkey 就是加密密钥，需要拥有用户 hash 才能计算出来，因此攻击者算不出来，就无法加解密包。但是想想就不可能，这个 session_key 已经在流量里面明文传输，那攻击者拿到之后不就可以直接加解密包了。当然这是后话，后面讲签名的时候会详细讲讲这个问题。</p>
<p><img src="./认证_files/31.png" alt=""></p>
</li>
</ul>
<p><img src="./认证_files/2.png" alt=""></p>
<p><strong>注意</strong></p>
<ol>
<li>Chanllenge 是 Server 产生的一个 16 字节的随机数，每次认证都不同</li>
<li>Response 的表现形式是 Net-NTLM Hash，它是由客户端提供的密码 Hash 加密 Server 返回的 Chanllenge 产生的结果。</li>
</ol>
<hr>
<h3 class="mume-header" id="ntlmv2">NTLMv2</h3>

<p>NTLMv1 和 NTLMv2 的加密因素都是 NTLM Hash，而最显著的区别就是 Challenge 和加密算法不同,共同点就是加密的原料都是 NTLM Hash。</p>
<ul>
<li>Challage： NTLMv1 的 Challenge 有 8 位，NTLMv2 的 Challenge 为 16 位。</li>
<li>Net-NTLM Hash：NTLMv1 的主要加密算法是 DES，NTLMv2 的主要加密算法是 HMAC-MD5。</li>
</ul>
<p>设置系统使用 LM 还是 NTLM 还是 NTLMv2，需要修改 Local Security Policy 中的 LmCompatibilityLevel 选项</p>
<p><img src="./认证_files/36.png" alt=""></p>
<hr>
<h3 class="mume-header" id="net-ntlm-hash">Net-NTLM hash</h3>

<p>在 type3 中的响应，有六种类型的响应</p>
<ol>
<li>LM(LAN Manager)响应 – 由大多数较早的客户端发送，这是“原始”响应类型。</li>
<li>NTLM v1 响应 – 这是由基于 NT 的客户端发送的，包括 Windows 2000 和 XP。</li>
<li>NTLMv2 响应 – 在 Windows NT Service Pack 4 中引入的一种较新的响应类型。它替换启用了 NTLM 版本 2 的系统上的 NTLM 响应。</li>
<li>LMv2 响应 – 替代 NTLM 版本 2 系统上的 LM 响应。</li>
<li>NTLM2 会话响应 – 用于在没有 NTLMv2 身份验证的情况下协商 NTLM2 会话安全性时，此方案会更改 LM NTLM 响应的语义。</li>
<li>匿名响应 – 当匿名上下文正在建立时使用; 没有提供实际的证书，也没有真正的身份验证。“存 根”字段显示在类型 3 消息中。</li>
</ol>
<p>这六种使用的加密流程一样，都是 Challenge/Response 验证机制,区别在 Challenge 和加密算法不同。</p>
<p>在以上流程中，登录用户的密码 hash 即 NTLM hash，其中，经过 NTLM Hash 加密 Challenge 的结果在网络协议中称之为 Net NTLM Hash，response 中包含 Net-NTLM hash.</p>
<p>在 NTLM 认证中，NTLM 响应分为 NTLM v1，NTLMv2，NTLM session v2 三种协议，不同协议使用不同格式的 Challenge 和加密算法.所以也就存在不同协议的 Net-NTLM hash，即 Net-NTLM v1 hash，Net-NTLM v2 hash</p>
<hr>
<p><strong>Net-NTLM v1 hash</strong></p>
<p>v1 是将 16字节的 NTLM hash 空填充为 21 个字节，然后分成三组，每组7比特，作为 3DES 加密算法的三组密钥，加密 Server 发来的 Challenge。 将这三个密文值连接起来得到 response。</p>
<p><strong>Net-NTLM v2 hash</strong></p>
<p>v2 将 Unicode 后的大写用户名与 Unicode 后的身份验证目标（在 Type 3 消息的”TargetName”字段中指定的域或服务器名称）拼在一起。请注意，用户名将转换为大写，而身份验证目标区分大小写，并且必须与“TargetName”字段中显示的大小写匹配。使用 16 字节 NTLM 哈希作为密钥，得到一个值。</p>
<p>建一个 blob 信息</p>
<p><img src="./认证_files/32.png" alt=""></p>
<p>使用 16 字节 NTLMv2 哈希作为密钥，将 HMAC-MD5 消息认证代码算法加密一个值(来自 type 2 的 Challenge 与 Blob 拼接在一起)。得到一个 16 字节的 NTProofStr。</p>
<p>将 NTProofStr 与 Blob 拼接起来形成得到 response。至于选择哪个版本的响应由 LmCompatibilityLevel 决定。</p>
<p>Challenge/Response 验证机制里面 type3 response 里面包含 Net-ntlm hash，NTLM v1 响应和 NTLMv2 响应对应的就是 Net-ntlm hash 分为 Net-ntlm hash v1 和 Net-ntlm hash v2。</p>
<p>Net-ntlm hash v1 的格式为：</p>
<blockquote>
<p>username::hostname:LM response:NTLM response:challenge</p>
</blockquote>
<p>Net-ntlm hash v2 的格式为：</p>
<blockquote>
<p>username::domain:challenge:HMAC-MD5:blob</p>
</blockquote>
<p>下面演示从 response 里面提取 NTLMv2</p>
<p><img src="./认证_files/33.png" alt=""></p>
<p>这里的 challenge 是 type2 服务器返回的 challenge 不是 type3 流量包里面的 client Challenge</p>
<p><img src="./认证_files/34.png" alt=""></p>
<p>就是 18f77b6fe9f8d876</p>
<p>HMAC-MD5 对应数据包中的 NTProofSt : 0ecfccd87d3bdb81713dc8c07e6705b6</p>
<p><img src="./认证_files/35.png" alt=""></p>
<p>blob 就是 response 减去 NTProofStr。(因为在计算 response 的时候，response 就是由 NTProofStr 加上 blob)</p>
<ul>
<li>username（要访问服务器的用户名）：Administrator</li>
<li>domain（访问者主机名或者 ip）：DESKTOP-QKM4NK7</li>
<li>challenge（数据包 2 中服务器返回的 challenge 值）：18f77b6fe9f8d876</li>
<li>HMAC-MD5（数据包 3 中的 NTProofStr）: 0ecfccd87d3bdb81713dc8c07e6705b6</li>
<li>blob（blob 对应数据为 NTLMv2 Response 开头去掉 NTProofStr 的后半部分）：01010000000000002a470d3bc233d6017eb1f527b5e7bd4d0000000002001e00570049004e002d0041003500470050004400430050004a0037004f00540001001e00570049004e002d0041003500470050004400430050004a0037004f00540004001e00570049004e002d0041003500470050004400430050004a0037004f00540003001e00570049004e002d0041003500470050004400430050004a0037004f005400070008002a470d3bc233d601060004000200000008003000300000000000000001000000002000003737fbe7dbcbd2c8e5d7a030f44586c91423d9c5202f827f3f6cf26f69adbfe80a001000000000000000000000000000000000000900280063006900660073002f003100390032002e003100360038002e003100340031002e003100330039000000000000000000</li>
</ul>
<p>所以最后，Net-NTLM v2 Hash 值为：</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>Administrator::DESKTOP-QKM4NK7:18f77b6fe9f8d876:0ecfccd87d3bdb81713dc8c07e6705b6:01010000000000002a470d3bc233d6017eb1f527b5e7bd4d0000000002001e00570049004e002d0041003500470050004400430050004a0037004f00540001001e00570049004e002d0041003500470050004400430050004a0037004f00540004001e00570049004e002d0041003500470050004400430050004a0037004f00540003001e00570049004e002d0041003500470050004400430050004a0037004f005400070008002a470d3bc233d601060004000200000008003000300000000000000001000000002000003737fbe7dbcbd2c8e5d7a030f44586c91423d9c5202f827f3f6cf26f69adbfe80a001000000000000000000000000000000000000900280063006900660073002f003100390032002e003100360038002e003100340031002e003100330039000000000000000000
</code></pre><p>上面的 Net-NTLM v2 Hash 值若使用 hashcat 爆破应为 Abcd1234</p>
<hr>
<h2 class="mume-header" id="%E5%9F%9F%E7%8E%AF%E5%A2%83%E4%B8%ADntlm%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F">域环境中NTLM认证方式</h2>

<ol>
<li>
<p>用户通过输入 Windows 帐号和密码登录客户端主机，客户端会缓存密码的哈希值 NTLM-Hash。成功登录客户端的用户如果试图访问服务器资源，需要向对方发送一个请求，该请求利用 NTLM SSP 生成 NTLM_NEGOTIATE 消息 （被称为 TYPE 1 消息，Negotiate 协商消息），并将 TYPE 1 消息发送给服务端中，该 TYPE 1 消息中包含一个以明文表示的用户名以及其他的一些协商信息(认证的主体，机器以及需要使用的安全服务等等信息)</p>
</li>
<li>
<p>服务端接收到客户端发送过来的 TYPE 1 消息，会读取其中的内容，并从中选择出自己所能接受的服务内容，加密等级，安全服务等等。然后传入 NTLM SSP，得到 NTLM_CHALLENGE 消息（被称为 TYPE 2 消息，Challenge 挑战消息），并将此 TYPE 2 消息发回给客户端。此 TYPE 2 消息中包含了一个由服务端生成的16位随机值，此随机值被称为 Challenge，服务器将该 Challenge 保存起来。</p>
</li>
<li>
<p>客户端收到服务端返回的 TYPE 2 消息， 读取出服务端所支持的内容，并取出其中的随机值 Challenge，用缓存的密码的哈希值 NTLM-Hash 对其进行加密，得到 Net NTLM-Hash(加密后的 Challenge)，并且将 Net NTLM-Hash 封装到 NTLM_AUTH 消息中（被称为 TYPE 3 消息， Authenticate认证消息），发往服务端。</p>
</li>
<li>
<p>服务器接收到客户端发送来的 NTLM_AUTH 的 TYPE 3 消息后，取出其中的 Net NTLM-Hash 值，并向 DC 域控（Domain Control）发送针对客户端的验证请求。该请求主要包含以下三方面的内容：客户端用户名、原始的 Challenge 和 加密后的 Challenge(也就是 Net NTLM-Hash)。</p>
</li>
<li>
<p>DC 根据用户名获取该帐号的密码哈希值 NTLM-Hash，用密码哈希值 NTLM-Hash 对原始的 Challenge 进行加密得到 Net NTLM-Hash。如果加密后的 Challenge 和服务器发送的一致，则意味着用户拥有正确的密码，验证通过，否则验证失败。DC 将验证结果发给服务器。</p>
</li>
<li>
<p>服务器根据 DC 返回的结果，对客户端进行回复。</p>
<p><img src="./认证_files/21.png" alt=""></p>
</li>
</ol>
<hr>
<h2 class="mume-header" id="ssp-sspi">SSP &amp; SSPI</h2>

<p><strong>SSPI(Security Support Provider Interface)</strong></p>
<p>这是 Windows 定义的一套接口，此接口定义了与安全有关的功能函数，用来获得验证、信息完整性、信息隐私等安全功能，就是定义了一套接口函数用来身份验证，签名等，但是没有具体的实现。</p>
<p><strong>SSP(Security Support Provider)</strong></p>
<p>SSPI 的实现者，对 SSPI 相关功能函数的具体实现。微软自己实现了如下的 SSP，用于提供安全功能：</p>
<ul>
<li>NTLM SSP</li>
<li>Kerberos</li>
<li>Cred SSP</li>
<li>Digest SSP</li>
<li>Negotiate SSP</li>
<li>Schannel SSP</li>
<li>Negotiate Extensions SSP</li>
<li>PKU2U SSP</li>
</ul>
<p>在系统层面，SSP 就是一个 dll，来实现身份验证等安全功能.不同的 SSP，实现的身份验证机制是不一样的。比如 NTLM SSP 实现的就是一种 Challenge/Response 验证机制。而 Kerberos 实现的就是基于 ticket 的身份验证机制。我们可以编写自己的 SSP，然后注册到操作系统中，让操作系统支持更多的自定义的身份验证方法。</p>
<p>我们抓包分析 ntlm 的时候，就会看到 ntlm 是放在 GSS-API 里面</p>
<p><img src="./认证_files/37.png" alt=""></p>
<p>为啥这里会出现 GSSAPI 呢，SSPI 是 GSSAPI 的一个专有变体，进行了扩展并具有许多特定于 Windows 的数据类型。SSPI 生成和接受的令牌大多与 GSS-API 兼容。所以这里出现 GSSAPI 只是为了兼容，我们可以不必理会。可以直接从 NTLM SSP 开始看起。注册为 SSP 的一个好处就是，SSP 实现了了与安全有关的功能函数，那上层协议(比如 SMB)在进行身份认证等功能的时候，就可以不用考虑协议细节，只需要调用相关的函数即可。而认证过程中的流量嵌入在上层协议里面。不像 kerbreos，既可以镶嵌在上层协议里面，也可以作为独立的应用层协议。ntlm 是只能镶嵌在上层协议里面，消息的传输依赖于使用 ntlm 的上层协议。比如镶嵌在 SMB 协议里,或镶嵌在 HTTP 协议。</p>
<hr>
<h1 class="mume-header" id="%E5%9F%9F%E8%AE%A4%E8%AF%81">域认证</h1>

<p>域认证部分内容来自 <sup>[<a href="https://b404.xyz/2019/07/23/Study-Windows-Authentication/">浅学Windows认证</a>]</sup><sup>、</sup><sup>[<a href="https://payloads.online/archivers/2018-11-30/1">彻底理解Windows认证 - 议题解读</a>]</sup></p>
<hr>
<h2 class="mume-header" id="kerberos">Kerberos</h2>

<p><strong>Kerberos 协议</strong></p>
<p>Kerberos 是一种计算机网络授权协议，用来在非安全网络中，对个人通信以安全的手段进行身份认证。软件设计上采用客户端/服务器结构，并且能够进行相互认证，即客户端和服务器端均可对对方进行身份认证。可以用于防止窃听、防止重放攻击、保护数据完整性等场合，是一种应用对称密钥体制进行密钥管理的系统。支持 SSO。Kerberos 的扩展产品也使用公开密钥加密方法进行认证。</p>
<p>当有N个人使用该系统时，为确保在任意两个人之间进行秘密对话，系统至少保存有它与每个人的共享密钥，所需的最少会话密钥数为N个。</p>
<p>Kerberos 协议基于对称密码学，并需要一个值得信赖的第三方。Kerberos 协议的扩展可以为认证的某些阶段提供公钥密码学支持。</p>
<p><img src="./认证_files/3.png" alt=""></p>
<hr>
<h3 class="mume-header" id="%E7%AE%80%E8%A6%81%E6%A6%82%E6%8B%AC%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B">简要概括认证过程</h3>

<p>Kerberos 认证用于域环境中，它是一种基于票据（Ticket）的认证方式。</p>
<p>客户端要访问服务器的资源，需要首先购买服务端认可的 ST 服务票据。也就是说，客户端在访问服务器之前需要预先买好票，等待服务验票之后才能入场。但是这张票不能直接购买，需要一张 TGT 认购权证(Ticket Granting Ticket)。也就是说，客户端在买票之前必须先获得一张 TGT 认购权证。这张 TGT 认购权证和 ST 服务票据均由 KDC 发售。</p>
<p>他的整个认证过程涉及到三方：客户端、服务端和 KDC（Key Distribution Center）。在 Windows 域环境中，由 DC(域控)来作为 KDC。</p>
<p>Kerberos 认证过程如下:</p>
<p><img src="./认证_files/25.png" alt=""></p>
<p><strong>Kerberos 认证所参与的角色</strong></p>
<ul>
<li>访问服务的 Client</li>
<li>提供服务的 Server</li>
<li>KDC(Key Distribution Center,密钥分发中心) = DC(Domain Controller)</li>
</ul>
<p>其中 KDC 服务默认安装在一个域的域控中，而 Client 和 Server 为域内的用户或者是服务，如 HTTP 服务、SQL 服务。在 Kerberos 中 Client 是否有权限访问 Server 端的服务由 KDC 发放的票据来决定</p>
<p><strong>认证中涉及到的部分词汇</strong></p>
<ul>
<li>AD(Account Database) : 活动目录,存储所有 Client 白名单，只有存在于白名单的 Client 才能申请到 AS 给的 TGT</li>
<li>DC(Domain Controller) : 域控</li>
<li>KDC(Key Distribution Center) : 密钥分发中心，由域控担任</li>
<li>KAS(Kerberos Authentication Service) : Kerberos 认证服务</li>
<li>TGT(Ticket Granting Ticket) : 入场券，通过入场券能够获得票据，是一种临时凭证的存在</li>
<li>TGS(Ticket Granting Server) : 为 client 生成某个服务的 ticket。 TGS 的作用是通过 AS 发送给 Client 的 TGT 换取访问 Server 端的 ST 票据。ST 也有资料称为 TGS Ticket，为了和 TGS 区分，此处使用 ST</li>
<li>ST(Ticket) : 票据,是网络对象互相访问的凭证。</li>
<li>Authentication Server : 为 Client 生成 TGT 的服务。 AS 的作用是验证 Client 端的身份，验证通过就会给一个 TGT 票据给 Client。</li>
<li>Session Key : 会话密钥，只有 Client 和 TGS 知道</li>
</ul>
<p><strong>获得认购权证</strong></p>
<p>首先，我们来看看客户端如何获得 <code>TGT 认购权证</code>。TGT 是 KDC 的 KAS 认证服务（Kerberos Authentication Service）发放的。</p>
<ol>
<li>
<p>当某个用户通过输入域帐号和密码试图登录某台主机的时候，本机的 Kerberos 服务会向 KDC 的 KAS 认证服务发送一个认证请求。该请求主要包括两部分内容，明文形式的用户名和用用户秘钥加密原始 <code>Authenticator</code> 后得到的加密后 <code>Authenticator</code>(Authenticator 是客户端和服务端可以用于验证对方身份的一个东西)。</p>
</li>
<li>
<p>当 KDC 接收到请求之后，通过 AD 查询该用户名得到该用户的信息。通过查询得到的密码信息对 <code>Authenticator</code> 进行解密得到原始的 <code>Authenticator</code>。如果解密后的 <code>Authenticator</code> 和已知的 <code>Authenticator</code> 一致，则证明请求者提供的密码正确，即确定了登录者的真实身份。KAS 成功认证对方的身份之后，会先生成一个用用户密码加密后的用于确保该用户和 KDC 之间通信安全的 <code>Logon Session Key</code> 会话秘钥。KAS 接着为该用户创建 <code>TGT 认购权证</code>。<code>TGT</code> 主要包含两方面的内容：用户相关信息和原始 <code>Logon Session Key</code>，而整个 <code>TGT</code> 则通过 KDC 自己的密钥进行加密。最终，被不同密钥加密的 <code>Logon Session Key</code> 和 <code>TGT</code> 返回给客户端。</p>
<p><img src="./认证_files/22.png" alt=""></p>
</li>
</ol>
<p><strong>获得 ST 服务票据</strong></p>
<p>经过上面的步骤，客户端获取了进入同域中其他主机入场券的 TGT 认购权证和 Logon Session Key，然后用自己的密钥解密 Logon Session Key 得到原始的 Logon Session Key。然后它会在本地缓存此 TGT 和原始 Logon Session Key。如果现在它需要访问某台服务器的资源，它就需要凭借这张 TGT 认购凭证向 KDC 购买相应的入场券。这里的入场券也有一个专有的名称——ST 服务票据（Service Ticket）。具体来说，ST 是通过 KDC 的另一个服务 TGS（Ticket Granting Service）出售的。</p>
<ol>
<li>
<p>客户端先向 TGS 发送一个 <code>ST 购买请求</code>，该请求主要包含如下的内容：客户端用户名、通过 <code>Logon Session Key</code> 加密的 <code>Authenticator</code>、<code>TGT</code> 和访问的服务器名(其实是服务)。</p>
</li>
<li>
<p>TGS 接收到请求之后，通过自己的秘钥解密 <code>TGT</code> 并得到原始 <code>Logon Session Key</code>，然后通过 <code>Logon Session Key</code> 解密 <code>Authenticator</code>，进而验证了对方的真实身份。TGS 完成对客户端的认证之后，会生成一个用 <code>Logon Session Key</code> 加密后的用于确保客户端-服务器之间通信安全的 <code>Service Session Key</code> 会话秘钥。然后为该客户端生成 <code>ST 服务票据</code>。<code>ST 服务票据</code>主要包含两方面的内容：客户端用户信息和原始 <code>Service Session Key</code>，整个 <code>ST</code> 通过服务器密码派生的秘钥进行加密。最终两个被加密的 <code>Service Session Key</code> 和 <code>ST</code> 回复给客户端。</p>
<p><img src="./认证_files/23.png" alt=""></p>
</li>
</ol>
<p><strong>用 ST 服务票据双向认证</strong></p>
<ol>
<li>
<p>客户端接收到 TGS 回复后，通过缓存的 <code>Logon Session Key</code> 解密得到原始 <code>Service Session Key</code>，同时它也得到了进入服务器 <code>ST 服务票据</code>。该 <code>Serivce Session Key</code> 和 <code>ST 服务票据</code> 会被客户端缓存。客户端访问某服务器资源，将 <code>ST 服务票据</code> 和 <code>Service Session Key</code> 加密的 <code>Authenticator</code> 发送给服务端。</p>
</li>
<li>
<p>服务器收到客户端发来的 <code>ST 服务票据</code>。但是，服务端如何确保客户端发来的 <code>ST 服务票据</code> 是通过 <code>TGS</code> 购买，而不是自己伪造的呢？这很好办，不要忘了 ST 是通过服务器自己密码派生的秘钥进行加密的。具体的操作过程是这样的，服务器在接收到请求之后，先通过自己密码派生的秘钥解密 <code>ST</code>，并从中提取 <code>Service Session Key</code>。然后通过提取出来的 <code>Service Session Key</code> 解密 <code>Authenticator</code>，进而验证了客户端的真实身份。实际上，到目前为止，服务端已经完成了对客户端的验证，但是，整个认证过程还没有结束。谈到认证，很多人都认为只是服务器对客户端的认证，实际上在大部分场合，我们需要的是双向验证（Mutual Authentication），即访问者和被访问者互相验证对方的身份。现在服务器已经可以确保客户端是它所声称的那么用户，客户端还没有确认它所访问的不是一个钓鱼服务呢。为了解决客户端对服务器的验证，服务端需要将解密后的 <code>Authenticator</code> 再次用 <code>Service Session Key</code> 进行加密，并发挥给客户端。客户端再用缓存的 <code>Service Session Key</code> 进行解密，如果和之前的内容完全一样，则可以证明自己正在访问的服务器和自己拥有相同的 <code>Service Session Key</code>。双向认证过后，开始了服务资源的访问。</p>
<p><img src="./认证_files/24.png" alt=""></p>
</li>
</ol>
<hr>
<h3 class="mume-header" id="%E8%AF%A6%E7%BB%86%E6%A6%82%E6%8B%AC%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B">详细概括认证过程</h3>

<p><img src="./认证_files/4.png" alt=""></p>
<p>当 Client 想要访问 Server 上的某个服务时，需要先向 AS 证明自己的身份，然后通过 AS 发放的 TGT 向 Server 发起认证请求，这个过程分为三块：</p>
<ul>
<li>The Authentication Service Exchange： Client 与 AS 的交互
<ul>
<li>AS_REQ</li>
<li>AS_REP</li>
</ul>
</li>
<li>The Ticket-Granting Service (TGS) Exchange： Client 与 TGS 的交互
<ul>
<li>TGS_REQ</li>
<li>TGS_REP</li>
</ul>
</li>
<li>The Client/Server Authentication Exchange： Client 与 Server 的交互
<ul>
<li>AP_REQ</li>
<li>AP_REP</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>每次交互 Client 可以收到两条消息，一条是可以解密的，一条是无法解密的</li>
<li>Client 期望访问的服务或者主机从不直接与 KDC 通信</li>
<li>KDC 存储了其数据库下所有主机和服务的密钥</li>
<li>密钥由密码加上一组随机数的哈希值，哈希算法由 Kerberos 的具体实现选择。对于服务和主机而言，其本身是没有密码的。一个密码实际上是由管理员的初始启动时产生和存储于服务和主机中的</li>
<li>所有密钥存储于 KDC 数据库</li>
<li>KDC 本身由主密钥加密</li>
<li>已经存在 Kerberos 的配置和实现采用公钥加密</li>
</ul>
<p>整体过程如图</p>
<p><img src="./认证_files/5.png" alt=""></p>
<ul>
<li>
<p><strong>用户登录</strong></p>
<p>用户登录阶段，通常由用户(AA)输入[用户名][密码]信息，在客户端侧，用户输入的密码信息被一个单向 Hash 函数生成 Client 密钥，即 AA 的 NTLM Hash：</p>
<p><img src="./认证_files/6.png" alt=""></p>
</li>
<li>
<p><strong>请求身份认证</strong></p>
<p><img src="./认证_files/7.png" alt=""></p>
<ul>
<li>
<p><strong>客户端向 AS 发送请求认证</strong></p>
<p>KRB-AS-REQ：Client 发送明文 <code>用户名 AA</code> 和 <code>Authenticator1</code> 信息到 KDC （Key Distribution Center）。Authenticator1 的内容为使用 Client 密码哈希加密的时间戳、Client ID、网络类型、加密类型等：</p>
</li>
<li>
<p><strong>AS 确认客户端登陆者身份</strong></p>
<p>KRB-AS-REP：AS 收到用户认证请求后，AS 根据请求中的 <code>用户名 AA</code> 信息，从数据库中查找用户名是否存在。如果 <code>用户名 AA</code> 存在，则从 KDC 中可以获取 <code>用户 AA</code> 的密码，使用单向函数为该密码生成一个 <code>Client 密钥</code>（即NTLM Hash）。</p>
<p>AS 生成随机字符串 <code>Client/TGS Session Key</code>，使用 <code>Client 密钥</code>(用户 AA 的密码 NTLM Hash )对 <code>Client/TGS Session Key</code> 加密得到 <code>sessionkey_as</code>；</p>
<p>再使用 TGS 密钥(krbtgt 用户的 NTLM Hash)对 <code>Client/TGS Session Key</code> 、 <code>Client Info</code> 和 <code>Timestamp</code> 加密,得到 <code>TGT</code>（TGT票据）。</p>
<p>将 <code>sessionkey_as</code> 和 <code>TGT</code> 一起返回给 Client。</p>
<p>Client 收到 AS 的响应消息后，利用自身的 <code>Client 密钥</code>（AA 的 NTLM Hash）对 <code>sessionkey_as</code> 解密，这样就获取到 <code>Client/TGS Session Key</code>。</p>
<blockquote>
<p>AS 的响应消息中有一条是属于 Client 的，有一条是 TGS 的。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>请求授权访问服务</strong></p>
<p><img src="./认证_files/10.png" alt=""></p>
<ul>
<li>
<p><strong>客户端向 TGS 发送请求服务授权请求</strong></p>
<p>KRB-TGS-REQ：Client 收到 <code>sessionkey_as</code> 和 <code>TGT</code> 后，使用 <code>Client 密钥</code>（AA 的 NTLM Hash）对 <code>sessionkey_as</code> 解密就能得到 <code>Client/TGS Session Key</code>，然后使用 <code>Client/TGS Session Key</code> 对 Client Info 和 timestamp 加密得到 <code>Authenticator2</code>。</p>
<p>将 <code>Authenticator2</code>、<code>TGT</code>、<code>Service ID</code>（要请求的服务 ID）发送给 KDC 中的 TGS。</p>
<blockquote>
<p>由于 TGT 是使用 <code>TGS 密钥</code>(krbtgt 的 NTLM Hash)加密的，Client 无法对 TGT 解密。</p>
</blockquote>
</li>
<li>
<p><strong>TGS 为 Client 响应服务授权票据</strong></p>
<p>TGS-REP：TGS 收到请求后，检查 KDC 数据库中是否存在所请求的服务(<code>Service ID</code>)。如果存在，TGS 使用 <code>TGS 密钥</code>(krbtgt 的 NTLM Hash)解密 TGT，得到 <code>Client/TGS Session Key</code>、timestamp、Client info；同时使用从 TGT 中解密得到的 <code>Client/TGS Session Key</code> 去解密 <code>Authenticator2</code>，得到 Client info 和 timestamp。 比对 <code>Authenticator2</code> 和 <code>TGT</code> 的解密内容以验证通过。</p>
<ul>
<li>TGS 比对 <code>Authenticator2</code> 包含的 <code>Client ID</code> 和 <code>TGT</code> 中的 <code>Client ID</code></li>
<li>比较时间戳（误差范围在2分钟）</li>
<li>通过生命周期字段检查 TGT 是否过期</li>
<li>检查 <code>Authenticator2</code> 已经不再 TGS 的缓存中</li>
<li>若原始请求中的网络地址不为 NULL，比较 TGT 中的 IP 和请求的 IP</li>
</ul>
<p>验证成功后，随机生成 Client 所请求服务的会话密钥 <code>Client/Server Session Key</code>；</p>
<p>使用 Server 密钥（即服务器计算机的NTLM Hash）对 <code>Client/Server Session Key</code>、<code>Client Info</code>（包含 Client ID）、<code>TimeStamp</code> 加密得到 <code>Client-To-Server Ticket</code>（也称为 ST 票据）；</p>
<p>使用 <code>Client/TGS Session Key</code> 对 <code>Client/Server Session Key</code> 加密得到 <code>sessionkey_tgs</code></p>
<p>最终将 <code>Client-To-Server Ticket</code>、<code>sessionkey_tgs</code> 返回给 Client。</p>
</li>
</ul>
</li>
<li>
<p><strong>请求服务</strong></p>
<p><img src="./认证_files/13.png" alt=""></p>
<ul>
<li>
<p><strong>Client 向 SS(Service Server)发送服务请求</strong></p>
<p>AP-REQ：Client 收到 <code>Client-To-Server Ticket</code>、<code>sessionkey_tgs</code> 之后，使用 <code>Client/TGS Session Key</code> 对 <code>sessionkey_tgs</code> 解密得到 <code>Client/Server Session Key</code>,然后使用 <code>Client/Server Session Key</code> 对 Client Info 和 timestamp 加密得到 <code>Authenticator3</code></p>
<p>将 <code>Authenticator3</code> 和 <code>Client-To-Server Ticket</code> 发送给所请求服务的服务器(<code>Service Server</code>)。</p>
</li>
<li>
<p><strong>Service Server 响应 Client</strong></p>
<p>AP-REP：Service Server 收到客户端的服务访问请求之后，利用 Server 密钥(Server 的 ntlm Hash)对 <code>Client-To-Server Ticket</code> 解密，提取出 <code>Client/Server SessionKey</code>、Client ID 等信息。</p>
<p>Service Server 使用 <code>Client/Server SessionKey</code> 对 <code>Authenticator3</code> 解密得到 Client ID 和 TimeStamp。</p>
<p>类似于 TGS，Service Server 也要做如下校验：</p>
<ul>
<li>Client ID;</li>
<li>时间戳；</li>
<li>ticket 是否过期；</li>
<li>避免重放攻击，查看 Service Server 的 cache 是否包含 authenticator3；</li>
<li>网络地址比较</li>
</ul>
<p>Service Server 发送最后的验证消息——用 <code>Client/Server SessionKey</code> 加密的 Timestamp 和 <code>Service ID</code> 数据包给 Client。</p>
<p>Client 收到之后，使用缓存的 <code>Client/Server SessionKey</code> 解密提取 Timestamp 信息，然后确认该信息与 Client 发送的 Authenticator3 中的 Timestamp 信息是否一致。验证通过后，在定义的通讯周期内，Client 可以使用票据请求 Service。</p>
<p>由此完成了 Client 和 Service Server 的双向认证。</p>
<ul>
<li>Kerberos 协议设计的思路就是用来在不受信的环境下进行认证的协议。</li>
<li>krbtgt 账号的 NTLM Hash 理论上只存在于 KDC 中。这意味着 TGT 只能由 KDC 来解密。如果 krbtgt 账号的 NTLM Hash 泄露了，那么 TGT 就能被解密甚至伪造。伪造的 TGT 叫做黄金票据。</li>
<li>Ticket 是由服务器计算机本身的 NTLM Hash 加密的，Client 不能解密。如果该 Hash 泄露，那么就可以解密甚至伪造 Ticket。伪造的 Ticket 叫做白银票据。</li>
<li>在上述的流程中，涉及到时间戳 timestamp，由于它的存在，才使得被第三方获取了加密信息 Authenticator1 、Authenticator2、TGT 不会在短时间内被暴力破解。timestamp 一般时间为8小时。</li>
<li>Kerberos 协议和 NTLM 协议都会使用 NTLM Hash 对生成的任意随机数加密，然后比对结果。 Kerberos 的主要区别在于添加了第三方——-KDC 参与到认证过程中。</li>
<li>Client info 中包含网络地址、Client ID 等信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 class="mume-header" id="pac">PAC</h2>

<p>上述为 RFC 规定的 Kerberos 认证授权流程(其中 NTLM Hash 是针对 Windows 举例的)，而微软所实现的 Kerberos 工作流程与之则有所不同，其区别的关键就在于，KDC 所返回的 <code>KRB_AS_REP</code> 中将包含一组 PAC 的信息。</p>
<p>PAC 的全称是 Privilege Attribute Certificate(特权属性证书)。其中所包含的是各种授权信息，例如用户所属的用户组、用户所具有的权限等。（User SID 和 Groups SID）</p>
<p>为了防止被伪造和串改，在 PAC 中包含有两个数字签名 <code>PAC_SERVER_CHECKSUM</code> 和 <code>PAC_PRIVSVR_CHECKSUM</code> ，这两个数字签名分别由 Server 端密码 HASH 和 KDC 的密码 HASH 加密。</p>
<p><img src="./认证_files/14.png" alt=""></p>
<p>正如上文所述，当用户与 KDC 之间完成了认证过程之后， 用户需要访问服务器所提供的某项服务时， 服务器为了判断用户是否具有合法的权限必须通过将用户的用户名传递给 KDC， KDC 通过得到的用户名查询用户的用户组信息，用户权限等，进而返回给服务器，服务器再将此信息与用户所索取的资源的 ACL 进行比较， 最后决定是否给用户提供相应的服务。</p>
<p>在 Windows 的 Kerberos 实现中， 默认情况下，<code>KRB_AS_REP</code> 信息中将包含一组 PAC 信息，也就是说，用户所得到的 TGT（TicketGranting Ticket）会包含用户的授权信息。用户再用包含有授权信息的 TGT 去申请相应的 Service Ticket，KDC 在收到这个 <code>KBR_AP_REQ</code> 请求的时候， 将 TGT 里的 PAC 信息解析出来， 加入到 Service Ticket 里返回。接下来， 当用户向服务器程序提交 <code>KRB_AP_REQ</code> 消息时， 服务器程序则将其中所包含的 PAC 信息传送给操作系统得到一个访问令牌， 并且同时将这个 PAC 的数字签名以 <code>KRB_VERIFY_PAC</code> 的消息传输给 KDC， KDC 再将验证这个 PAC 的数字签名的结果以 RPC 返回码的形式告诉服务器， 服务器就可以根据这个结果判断 PAC 数据的真实性和完整性，并做出最后对 <code>KRB_AP_REQ</code> 的判断。</p>
<ul>
<li>优点：
<ul>
<li>以后对资源的访问中，服务端再接收到客户的请求的时候不再需要借助 KDC 的帮助提供完整的授权信息来完成对用户权限的判断， 而只需要根据请求中所包含的 PAC 信息直接与本地资源的 ACL 相比较做出裁决。</li>
<li>解决 PAC 欺骗，防止攻击者利用篡改的 PAC 信息实现未授权访问</li>
</ul>
</li>
<li>缺点：
<ul>
<li>PAC 在用户的认证阶段引入会导致认证耗时过长。（Windows Kerberos 客户端会通过 RPC 调用 KDC 上的函数来验证 PAC 信息，这时候用户会观察到在服务器端与 KDC 之间的 RPC 包流量的增加。）</li>
<li>由于 PAC 是微软特有的一个特性，所以启用了 PAC 的域中将不支持装有其他操作系统的服务器，制约了域配置的灵活性</li>
</ul>
</li>
</ul>
<hr>
<h2 class="mume-header" id="spn">SPN</h2>

<p>服务主体名称（SPN：Service Principal Names）是服务实例（可以理解为一个服务，比如HTTP、MSSQL）的唯一标识符（即服务器上所运行服务的唯一标识）。Kerberos使用SPN将服务实例与服务登录帐户相关联。如果在整个域 或 域林中的计算机上安装多个服务实例，则每个实例都必须具有自己的SPN。如果客户端使用多个名称进行身份验证，则给定的服务实例具有多个SPN。SPN始终包含运行服务实例的主机名称，因此服务实例可以为其主机的每个名称或别名注册SPN。</p>
<blockquote>
<p>使用 Kerberos 的域认证认证服务，需要正确配置 SPN</p>
</blockquote>
<p>SPN 在其注册的域林中必须是唯一的，若不唯一，则身份验证就会失败。</p>
<p>SPN 的格式：</p>
<pre data-role="codeBlock" data-info="" class="language-"><code>&lt;service type&gt;/&lt;host&gt;:&lt;port&gt;/&lt;DistinguishedName&gt;

// &lt;service type&gt;：服务类型，如LDAP、TERMSRV、SMTP、MSSQL、HTTP
// &lt;host&gt;：服务所在主机名称，可以是FQDN(如data.test.lab、server.test.lab)和NetBIOS名(如data、server)

// &lt;port&gt;：服务端口，若服务运行在默认端口上，则端口号可以省略
// &lt;Distinguished Name&gt;：专有名称
</code></pre><p>通用服务类型 ,可参考 <a href="https://adsecurity.org/?page_id=183">https://adsecurity.org/?page_id=183</a></p>
<hr>
<h2 class="mume-header" id="%E5%A7%94%E6%B4%BE">委派</h2>

<p>委派(Delegation)：是一种让用户可以委托服务器代表自己与其他服务进行验证的功能，它允许服务账户在活动目录中模拟其他域用户身份，主要用于当服务需要以某个用户的身份来请求访问其他服务资源的场景。比如，在域内，用户 Jack 经过 Kerberos 身份验证访问服务 Web（服务 web 处于域），Web 服务再以 Jack 的身份去请求域中的服务 MSSQL，若 Jack 有权限访问就能访问成功，这种过程就是委派的一个过程。</p>
<p>域委派的4种主要方式：</p>
<ul>
<li>无约束委派
<ul>
<li>表示您授予该帐户权限以委派任何服务，前提是满足启动委派所需的所有其他步骤。</li>
<li>从 IT 安全角度来看，此选项最容易配置但安全性最低。</li>
</ul>
</li>
<li>约束委派 - 仅限 Kerberos
<ul>
<li>更安全，它将委派任务限制到指定列表，不像无约束委派允许委派给任何服务。</li>
<li>与无约束委派相比，需要额外配置。</li>
<li>必须确保在帐户上设置 SPN 并添加允许帐户委派的服务。</li>
</ul>
</li>
<li>协议转换</li>
<li>基于资源的约束委派</li>
</ul>
<p>用户在 Kerberos 认证中访问服务 A 和服务 B 的过程图：</p>
<p><img src="./认证_files/15.png" alt=""></p>
<p>后改进了这种同一用户访问多服务的过程，实现了 A 服务模拟用户访问 B 服务的过程。</p>
<p>在用户发送一个 ST(图中为 TGS)访问服务时，连同其TGT一起发送，服务 A 使用用户的 TGT 向服务B进行 ST(图中为 TGS)，进而简化了用户请求服务 B 资源时验证访问的认证过程。这种就是无约束委派（TrustedForDelegation）的过程：</p>
<p><img src="./认证_files/16.png" alt=""></p>
<p>无约束委派过程中，如果攻击者截获了 Service A 验证的 ST 和 TGT，就可以用它们访问服务 B，进而模拟管理员访问任意服务，漫游内网。</p>
<h3 class="mume-header" id="%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE">约束委派</h3>

<p>为了解决无约束委派的隐患，微软发布了约束委派（S4U2Proxy）。</p>
<p>若服务 A 允许委派给服务B，则 A 能使用 S4U2Proxy 协议将用户发送的 TS(图中的 TGS，TGS 必须是可转发的) 再转发给域控制器认证，为用户请求访问服务 B 的 TS(图中的 TGS)。接着，服务 A 就能使用新获得的 TS(图中的 TGS）模拟用户访问服务 B:</p>
<p><img src="./认证_files/17.png" alt=""></p>
<p>上图中用户是通过 Kerberos 协议与服务 A 进行认证的，而当用户以其他方式(如 NTLM 认证，基于表单的认证等方式)与 Web 服务器进行认证后，用户是无法向 Web 服务器提供请求该服务的 TS(图中的 TGS)，因而服务器 A 也无法进一步使用 S4U2Proxy 协议请求访问服务 B。S4U2Self 协议便是解决该问题的方案，被设置为 <code>TrustedToAuthForDelegation</code> 的服务能够调用 S4U2Self 向认证服务器为任意用户请求访问自身的可转发的服务票据，此后，便可通过 S4U2Proxy 使用这张 TGS 向域控制器请求访问 B 的票据。这就是协议转换委派(S4U2Self/TrustedToAuthForDelegation)：</p>
<p><img src="./认证_files/18.png" alt=""></p>
<hr>
<h3 class="mume-header" id="%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE">基于资源的约束委派</h3>

<p>传统的约束委派中仍然存在一些缺点，如无法进行跨域委派。微软在 Windows Server 2012 中引入了基于资源的约束委派，相对于传统的约束委派，主要有三处改进:</p>
<ul>
<li>委派的权限授予给了拥有资源的后端(B)而不再是前端(A)</li>
<li>不再需要域管理员权限设置委派，只需拥有在计算机对象上编辑 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code> 属性的权限</li>
<li>委派功能现在可以跨域和林</li>
</ul>
<p><img src="./认证_files/19.png" alt=""></p>
<p>基于资源的约束委派(Resource-Based Constrained Delegation)是一种允许资源自己去设置哪些账户委派给自己的约束委派。</p>
<p>传统的约束委派是“正向的”，通过修改服务 A 属性 <code>msDS-AllowedToDelegateTo</code>，添加服务 B 的 SPN（Service Principle Name），设置约束委派对象（服务 B），服务 A 便可以模拟用户向域控制器请求访问服务B以获得服务票据（TGS）来使用服务 B 的资源。</p>
<p>而基于资源的约束委派则是相反的，通过修改服务 B 属性 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>，添加服务 A 的 SPN，达到让服务 A 模拟用户访问 B 资源的目的。</p>
<hr>
<p><strong>Source &amp; Reference</strong></p>
<ul>
<li><a href="https://klionsec.github.io/2016/08/10/ntlm-kerberos/">深刻理解windows安全认证机制</a></li>
<li><a href="https://www.sqlsec.com/2019/11/winhash.html#toc-heading-2">Windows用户密码的加密方法与破解</a></li>
<li><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/">Windows下的密码hash——NTLM hash和Net-NTLM hash介绍</a></li>
<li><a href="https://b404.xyz/2019/07/23/Study-Windows-Authentication/">浅学Windows认证</a></li>
<li><a href="https://mp.weixin.qq.com/s/MhxGey_xVqv12CUJ7P8UjA">技术干货 | Windows认证体系解读</a></li>
<li><a href="https://payloads.online/archivers/2018-11-30/1">彻底理解Windows认证 - 议题解读</a></li>
<li><a href="https://en.wikipedia.org/wiki/NT_LAN_Manager">NT LAN Manager - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/LAN_Manager">LAN Manager - Wikipedia</a></li>
<li><a href="https://www.anquanke.com/post/id/193149">Windows内网协议学习NTLM篇之NTLM基础介绍</a></li>
</ul>

      </div>
      
      
    
    
    
    
    
    
    
    
  </body></html>